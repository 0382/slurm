/*****************************************************************************
 *  smd_ns.c - Library for fault tolerant application support
 *****************************************************************************
 *  Copyright (C) 2013 SchedMD LLC
 *  Written by Morris Jette <jette@schedmd.com>
 *  Written by David Bigagli <david@schemd.com>
 *  All rights reserved
 *****************************************************************************/

/* Include the library header file which then
 * includes all unix headers we need.
 */
#include <slurm/smd_ns.h>

#define MAX_MSG_SIZE (1024 * 1024)	/* 1 MB */
#define POLL_TIMEOUT 10000		/* msec */
#define MSG_SIZE  128
#define TIMEBUFSIZ 64
#define BUFSIZ2    512

#define HDR_VERSION_LEN 16
#define HDR_OPCODE_LEN 64

typedef struct smd_header {
	char version[HDR_VERSION_LEN];
	char opcode[HDR_OPCODE_LEN];
} smd_header_t;

/* Here we now define the vectore of errror
 * messages which is defined in smd_ns.h
 * The error messages from the library are
 * a union of library specific errors and the
 * errors that may happen between the library
 * and the controller.
 */
struct ns_err_tab {
	int num;
	char *msg;
};
static struct ns_err_tab nserrtab[] =
{
	{ENSTOP_OK,		"No error"},
	{ENSTOP_CONFIG,		"Invalid configuration"},
	{ENSTOP_NETIO,		"Network I/O error with controller"},
	{ENSTOP_INVALCMD,	"Invalid command sent to controller"},
	{ENSTOP_UPNODE,		"Update node failed"},
	{ENSTOP_JOBID,		"Invalid job ID"},
	{ENSTOP_PORT,		"Invalid port"},
	{ENSTOP_UID,		"Invalid user ID"},
	{ENSTOP_JOBNOTRUN,	"Job is not running"},
	{ENSTOP_NOHOST,		"Specified host is not found"},
	{ENSTOP_NODENOTFAILED,	"Node has not failed"},
	{ENSTOP_NODENOTINJOB,	"Node is not in the specified job's allocation"},
	{ENSTOP_REPLACELATER,	"Node replacement is available later"},
	{ENSTOP_REPLACEPENDING,	"A previous replace request is pending"},
	{ENSTOP_MAXSPARECOUNT,	"Job has reached MaxSpareNodeCount limit"},
	{ENSTOP_NODEREPLACEFAILED, "Failed to replace the node"},
	{ENSTOP_NOINCREASETIMELIMIT, "Not eligible for time limit increase"},
	{ENSTOP_TIMEOVERLIMIT,	"Requested time exceeed the limit"},
	{ENSTOP_JOBUPDATE,	"Failed to update the job"},
	{ENSTOP_DECODEHEADER,	"Failed decoding header from the controller"},
	{ENSTOP_UNKWNCTRLMSG,	"Unknown message from controller"},
	{ENSTOP_PROTOCOL,	"Protocol error with controller"},
	{ENSTOP_NONODEFAIL,	"The specified node has not failed"},
	{ENSTOP_LASTERR,	"Unknown error"}
};

/* String protocol header messages from the controller.
 * The library translate the message sent from the controller
 * into errno which is known to users. The enum that includes
 * these errors is defined in smd_ns.h.
 static char *ctrl_header_msg[] =
 {
 "ENOERROR",
 "ECMD",
 "EUPDNODE",
 "EJOBID",
 "EPERM",
 "EPORT",
 "EUID",
 "EJOBNOTRUN",
 "ENOHOST",
 "ENODEFAILED",
 "NODENOTINJOB",
 "EREPLACELATER",
 "EREPLACEPENDING",
 "EMAXSPARECOUNT",
 "ENODEREPLACEFAILED",
 "ENOINCREASETIMELIMIT",
 "ETIMEOVERLIMIT",
 "EJOBUPDATE",
 "ENONODEFAIL"
 NULL
 };
*/

/* These enums are the entry points in
 * the array of nonstop_vars. The server
 * and the library share the same nonstop.conf
 * file but they may use different parts of it.
 */
enum {
	NONSTOP_CONTROLADDR,
	NONSTOP_BACKUPADDR,
	NONSTOP_PORT,
	NONSTOP_DEBUG,
	NONSTOP_READTIMEOUT,
	NONSTOP_WRITETIMEOUT
};

/* This array keeps the configuration
 * values needed by the library.
 * The array entries must correspond
 * to the enum above.
 */
static struct config_var vars[] =
{
	{"ControlAddr", NULL},
	{"BackupAddr", NULL},
	{"Port", NULL},
	{"Debug", NULL},
	{"ReadTimeout", NULL},  /* seconds */
	{"WriteTimeout", NULL}, /* seconds */
	{ NULL, NULL}
};

/* Default nonstop.conf configuration file from
 * Makefile generated by configure.
 */
extern char *default_slurm_config_file;

/* Library runtime parameters of the
 * nonstop system as read and processed
 * by the configuration.
 */
static struct nonstop_config *lib_config;

/* We may need to lock stuff here and there
 * for data structure protection in case
 * the caller is invoking the library from
 * multiple threads.
 */
static pthread_mutex_t conf_lock = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t log_lock = PTHREAD_MUTEX_INITIALIZER;

/* This data structure holds the port and the socket
 * the library uses to listen for incoming messages
 * from the controller if it works in asynchronous mode.
 */
struct listener {
	int event_sock;
	uint16_t port;
};
static struct listener lstnr;

static char *_clean_str(const char *in_str);
static char *_encrypt(char *msg);
static void _free_config(void);
static int  _ns_read(int fd, char **resp);
static int  _ns_write(int fd, char *msg);
static int  _read_config(void);
static int  _read_bytes(int fd, char *msg, int msg_size);
static int  _send_msg(char *msg, char **resp);
static int  _write_bytes(int fd, char *msg, int msg_size);
static int  _conf(const char *file, struct config_var *v);
static char *_nextline(FILE *fp, char *buf, int l);
static char *_chop(char *string);
static int  _matchKeys(char *line, struct config_var *v);
static char *_get_config_file_name(char *file);
static int  _decode_header(smd_header_t *, const char *msg);
static char *_decode_payload(smd_header_t *, char *msg);
static int  _count_ntuples(char *, int);

/* The public API
 */

/*
 * Get a list of failed nodes for the specified job
 * IN job_id - The job to status
 * OUT resp - Comma separated list of node names with CPU counts
 *			NOTE: caller must free returned memory
 * RET 0 on success or -1 on failure and set errno
 */
extern int smd_get_job_faulty_nodes(struct faulty_node_request *request,
                                    struct faulty_node_reply *reply)
{
	char send_msg[MSG_SIZE];
	char *resp_msg;
	char *buf;
	int rc;
	int cc;
	int num;
	struct node_state *nodes;
	smd_header_t hdr;

	if (request == NULL) {
		errno = EINVAL;
		return -1;
	}

	/* Zero out the structure for the caller in
	 * case it is allocated on the stack and
	 * copy the job_id.
	 */
	memset(reply, 0, sizeof(struct faulty_node_reply));
	reply->job_id = request->job_id;

	if (request->options == 0) {
		/* 0x2 | 0x4 = 0x6
		 */
		request->options =  (FAILED_NODES | FAILING_NODES);
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Invalid configuration detected",  __func__);
		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: job_id %u options bits 0x%x",  __func__,
		             request->job_id, request->options);
	}

	snprintf(send_msg, sizeof(send_msg), "\
GET_FAIL_NODES:JOBID:%u:STATE_FLAGS:%u", request->job_id, request->options);

	resp_msg = NULL;
	rc = _send_msg(send_msg, &resp_msg);
	if (rc < 0) {
		freeit(resp_msg);
		errno = ENSTOP_NETIO;
		return -1;
	}

	rc = _decode_header(&hdr, resp_msg);
	if (rc < 0) {
		freeit(resp_msg);
		/* caller to examine errno
		 */
		return -1;
	}

	if (errno != ENSTOP_OK) {
		freeit(resp_msg);
		return -1;
	}

	/* buf now points somewhere in the middle
	 * of resp_msg, strdup() it if you want to
	 * keep it.
	 */
	buf = _decode_payload(&hdr, resp_msg);
	if (buf == NULL) {
		freeit(resp_msg);
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	/* The payload is sent in triplets
	 * node_name cpu_count node_state
	 */
	num = _count_ntuples(buf, 3);
	if (num < 0) {
		freeit(resp_msg);
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: got num hosts states %d",  __func__, num);
	}

	/* If no host failed notify the user and no
	 * point going ahead allocating 0 memory.
	 */
	if (num == 0) {
		reply->num = 0;
		reply->nodes = NULL;
		freeit(resp_msg);
		return 0;
	}

	/* Build the array of nodes returned from the
	 * controller.
	 */
	nodes = calloc(num, sizeof(struct node_state));
	if (nodes == NULL) {
		freeit(resp_msg);
		return -1;
	}

	for (cc = 0; cc < num; cc++) {
		int offset;

		nodes[cc].node_name = calloc(MAXHOSTNAMELEN, sizeof(char));
		if (nodes[cc].node_name == NULL) {
			freeit(resp_msg);
			for (num = 0; num < cc; num++)
				freeit(nodes[num].node_name);
			freeit(nodes);
			reply->num = 0;
			reply->nodes = NULL;
			return -1;
		}
		sscanf(buf, "\
%s%d%d%n", nodes[cc].node_name, &nodes[cc].cpu_cnt, &nodes[cc].state, &offset);

		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: node %s cpu_count %d state 0x%x",  __func__,
			             nodes[cc].node_name, nodes[cc].cpu_cnt, nodes[cc].state);
		}

		buf = buf + offset;
	}

	reply->num = num;
	reply->nodes = nodes;

	freeit(resp_msg);
	errno = ENSTOP_OK;
	/* Good bye.
	 */
	return 0;
}

/* smd_free_job_faulty_nodes()
 */
extern void
smd_free_job_faulty_nodes_reply(struct faulty_node_reply *reply)
{
	int cc;

	if (reply == NULL)
		return;

	for (cc = 0; cc < reply->num; cc++)
		freeit(reply->nodes[cc].node_name);
	freeit(reply->nodes);

	reply->num = 0;
	reply->nodes = NULL;
}

/* smd_drain_node()
 *
 * Advise Slurm to drain specific node.
 * IN drain node request data structure
 * RET 0 on success or -1 on failure and set errno
 */
extern int smd_drain_job_node(struct drain_node_request *request)
{
	smd_header_t hdr;
	char *clean_node_names;
	char *clean_reason;
	char *resp_msg;
	char *send_msg;
	int len;
	int rc;

	if (request == NULL
	    || request->node == NULL
	    || request->job_id <= 0) {
		errno = EINVAL;
		return -1;
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Invalid configuration detected.",  __func__);
		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: job_id %u.",  __func__, request->job_id);
	}

	if (request->reason == NULL)
		request->reason = "";

	clean_node_names = _clean_str(request->node);
	clean_reason = _clean_str(request->reason);
	len = strlen(clean_node_names) + strlen(clean_reason) + 128;
	send_msg = calloc(len, sizeof(char));

	/* Build up the protocol message.
	 */
	snprintf(send_msg, len, "\
DRAIN:NODES:\"%s\":REASON:\"%s\"", clean_node_names, clean_reason);
	resp_msg = NULL;
	rc = _send_msg(send_msg, &resp_msg);
	if (rc < 0) {
		/* errno set in the IO layer
		 */
		freeit(send_msg);
		freeit(clean_node_names);
		freeit(clean_reason);
		return -1;
	}

	rc = _decode_header(&hdr, resp_msg);

	/* No matter if return 0 or -1 the
	 * memory needs to be freed.
	 */
	freeit(resp_msg);
	freeit(send_msg);
	freeit(clean_node_names);
	freeit(clean_reason);

	if (errno == ENSTOP_OK)
		return 0;

	/* All other error situation return -1
	 * and the caller has to examine the
	 * errno.
	 */
	return -1;
}

/* smd_replace_node()
 * Replace a failed or down node for the specified job
 */
extern int smd_replace_job_node(struct replace_node_request *request,
                                struct replace_node_reply *reply)
{
	smd_header_t hdr;
	char send_msg[MSG_SIZE];
	char key[128], value[MSG_SIZE];
	char *resp_msg;
	int n, rc;

	if (request == NULL
	    || request->node == NULL
	    ||reply == NULL) {
		errno = EINVAL;
		return -1;
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Invalid configuration detected.",  __func__);
		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: job_id %u.",  __func__, request->job_id);
	}

	snprintf(send_msg, sizeof(send_msg), "\
REPLACE_NODE:JOBID:%u:NODE:%s", request->job_id, request->node);
	resp_msg = NULL;
	rc = _send_msg(send_msg, &resp_msg);
	if (rc < 0) {
		/* errno set in the IO layer
		 */
		freeit(resp_msg);
		return -1;
	}

	/* Possible protocol message the 1.0 library expects from the controller.
	 *
	 * "1.0 ENOERROR ercole"
	 * "1.0 ENODEREPLACEFAILED Requested node configuration is not available"
	 * "1.0 EJOBID"
	 * "1.0 EJOBNOTRUN"
	 * "1.0 ENOHOST"
	 * "1.0 EMAXSPARECOUNT 2"
	 * "1.0 ECMD"
	 * "1.0 EREPLACELATER jobid time_t
	 * "1.0 ENODEFIRSTTOREPLACE node name"
	 * "1.0 ENODENOTFAILED"
	 * "1.0 NODENOTINJOB"
	 */

	rc = _decode_header(&hdr, resp_msg);
	if (rc < 0) {
		freeit(resp_msg);
		return -1;
	}

	/* The call did what we hoped for and the
	 * controller is sending us a new node to
	 * replace the failed one.
	 */
	if (errno == ENSTOP_OK) {
		char *buf;

		reply->when_available = time(NULL);
		reply->job_id = request->job_id;
		reply->failed_node = strdup(request->node);
		reply->replacement_node = NULL;
		reply->new_set.new_nodelist = NULL;
		reply->new_set.new_node_cnt = 0;
		reply->new_set.new_cpus_per_node = NULL;
		buf = _decode_payload(&hdr, resp_msg);
		if (buf == NULL) {
			freeit(resp_msg);
			errno = ENSTOP_PROTOCOL;
			return -1;
		}

		while ((rc = sscanf(buf, "%s%s%n", key, value, &n)) == 2) {
			buf = buf + n;
			if (strcmp(key, "ReplacementNode") == 0) {
				reply->replacement_node = strdup(value);
				continue;
			}
			if (strcmp(key, "NewNodeList") == 0) {
				reply->new_set.new_nodelist = strdup(value);
				continue;
			}
			if (strcmp(key, "NewNodeCount") == 0) {
				reply->new_set.new_node_cnt = atoi(value);
				continue;
			}
			if (strcmp(key, "NewCpusPerNode") == 0) {
				reply->new_set.new_cpus_per_node = strdup(value);
				continue;
			}
		}

		if (lib_config->debug) {
			smd_log_time(stderr,
			             "%s: ReplacementNode=%s "
			             "NewNodeList=%s NewNodeCount=%d "
			             "NewCpusPerNode=%s",
			             __func__,
			             reply->replacement_node,
			             reply->new_set.new_nodelist,
			             reply->new_set.new_node_cnt,
			             reply->new_set.new_cpus_per_node);
		}
		freeit(resp_msg);
		/* this is a postive reply
		 * the operation succeeded
		 */
		return 0;
	}

	/* There are no nodes available now but there
	 * is a time estimate returning from the controller
	 * about when the job can be replaced.
	 */
	if (errno == ENSTOP_REPLACELATER) {
		char *later_time;

		later_time = _decode_payload(&hdr, resp_msg);
		if (later_time == NULL) {
			freeit(resp_msg);
			errno = ENSTOP_PROTOCOL;
			return -1;
		}
		reply->job_id = request->job_id;
		reply->failed_node = strdup(request->node);
		reply->replacement_node = NULL;
		reply->when_available = atoi(later_time);
		reply->new_set.new_nodelist = NULL;
		reply->new_set.new_node_cnt = 0;
		reply->new_set.new_cpus_per_node = NULL;

		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: node available later at %lu",  __func__, reply->when_available);
		}
		freeit(resp_msg);
	}

	/* A node cannot be replace. The caller should examine the
	 * the errno and the smd_nostop_errstr() to see
	 * what error happened.
	 */
	return -1;
}

/* smd_free_replace_job_node_reply()
 *
 * Free the members of the replace node reply data structure.
 * Note we don't free the pointer itself as the user might
 * have allocated the structure on the stack.
 */
extern void
smd_free_replace_job_node_reply(struct replace_node_reply *reply)
{
	freeit(reply->failed_node);
	freeit(reply->replacement_node);
	freeit(reply->new_set.new_nodelist);
	freeit(reply->new_set.new_cpus_per_node);
}
/*
 * Increase the time limit of a job
 * IN job_id - The job to modify
 * IN minutes - The number of minutes to add to a job's time limit,
 *		If zero, then allocate the maximum possible
 * RET 0 on success or -1 on failure and set errno
 */
extern int smd_extend_job_time(struct job_time_extend_request *extend)
{
	smd_header_t hdr;
	char send_msg[MSG_SIZE];
	char *resp_msg;
	int rc;

	if (extend == NULL
	    || extend->job_id <= 0
	    || extend->minutes <= 0) {
		errno = EINVAL;
		return -1;
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Invalid configuration detected.",  __func__);

		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: job_id %u.",  __func__, extend->job_id);
	}

	snprintf(send_msg, sizeof(send_msg), "\
TIME_INCR:JOBID:%u:MINUTES:%u", extend->job_id, extend->minutes);

	resp_msg = NULL;
	rc = _send_msg(send_msg, &resp_msg);
	if (rc < 0) {
		/* errno set in the IO layer
		 */
		freeit(resp_msg);
		return -1;
	}

	rc = _decode_header(&hdr, resp_msg);
	if (rc < 0) {
		freeit(resp_msg);
		return -1;
	}
	freeit(resp_msg);

	/* The opration succeeded.
	 */
	if (errno == ENSTOP_OK)
		return 0;

	/* The operation failed, user to examine
	 * the errno and smd_nonstop_errstr()
	 * to determine the problem.
	 */
	return -1;
}

/* smd_free_node_state()
 */
extern void
smd_free_node_state(struct node_state *ns)
{
	freeit(ns->node_name);
	ns->cpu_cnt = ns->state = 0;
}

/* smd_register4nodevent()
 * This initiate the async communication with
 * the controller.
 * Send to the controller the registration event in
 * the form of: CALLBACK:JOBID:#:PORT:#
 */
extern int
smd_register4nodevent(uint32_t job_id)
{
	smd_header_t hdr;
	char send_msg[MSG_SIZE];
	char *resp_msg;
	int cc;
	socklen_t len;
	struct sockaddr_in serv_addr;

	if (job_id < 0) {
		errno = EINVAL;
		return -1;
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Invalid configuration detected.",  __func__);

		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: job_id %u.",  __func__, job_id);
	}

	/* This is the event socket used to wait
	 * for events from the controller.
	 */
	lstnr.event_sock = socket(AF_INET, SOCK_STREAM, 0);
	if (lstnr.event_sock < 0) {
		errno = ENSTOP_NETIO;
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: socket() failed %s",  __func__, strerror(errno));
		}
		return -1;
	}

	memset(&serv_addr, 0, sizeof(serv_addr));
	serv_addr.sin_family = AF_INET;
	serv_addr.sin_addr.s_addr = lib_config->control_saddr;
	serv_addr.sin_port = INADDR_ANY;

	cc = bind(lstnr.event_sock, (struct sockaddr *)&serv_addr, sizeof(struct sockaddr_in));
	if (cc < 0) {
		errno = ENSTOP_NETIO;
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: bind() socket %d failed %s",  __func__,
			             lstnr.event_sock, strerror(errno));
		}
		closeit(lstnr.event_sock);
		return -1;
	}

	cc = listen(lstnr.event_sock, SOMAXCONN);
	if (cc < 0) {
		errno = ENSTOP_NETIO;
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: listen() socket %d failed %s",  __func__,
			             lstnr.event_sock, strerror(errno));
		}
		closeit(lstnr.event_sock);
		return -1;
	}

	len = sizeof(struct sockaddr_in);
	cc = getsockname(lstnr.event_sock, (struct sockaddr *)&serv_addr, &len);
	if (cc < 0) {
		errno = ENSTOP_NETIO;
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: getsockname() socket %d failed %s",  __func__,
			             lstnr.event_sock, strerror(errno));
		}
		closeit(lstnr.event_sock);
		return -1;
	}
	/* The controller wants the port in the host
	 * order.
	 */
	lstnr.port = ntohs(serv_addr.sin_port);

	snprintf(send_msg, sizeof(send_msg), "\
CALLBACK:JOBID:%u:PORT:%d", job_id, lstnr.port);

	resp_msg = NULL;
	cc = _send_msg(send_msg, &resp_msg);
	if (cc < 0) {
		/* errno set in the IO layer
		 */
		closeit(lstnr.event_sock);
		freeit(resp_msg);
		return -1;
	}

	cc = _decode_header(&hdr, resp_msg);
	if (cc < 0) {
		freeit(resp_msg);
		closeit(lstnr.event_sock);
		return -1;
	}
	freeit(resp_msg);

	/* Registration operation succeeded.
	 */
	if (errno == ENSTOP_OK)
		return 0;

	/* Registration operation failed.
	 */
	return -1;
}

/* int smd_wait4nodevent()
 * This function waits for a specified time
 * for an event to happen. Events could
 * be asynchronous so the caller has to analyze
 * the event type and eventually restart the
 * call. The
 */
extern int
smd_wait4nodevent(uint32_t job_id,
                  struct node_event *ev,
                  int timeout)
{
	struct pollfd v;
	int cc;
	int s;
	socklen_t len;
	uint32_t event;
	uint32_t size;
	struct sockaddr_in from;

	if (job_id <= 0
	    || ev == NULL) {
		errno = EINVAL;
		return -1;
	}

	/* The socket is not initialized meaning the
	 * configuration has not been read yet and the
	 * event listener not initialized.
	 */
	if (lstnr.event_sock < 0) {
		errno = EINVAL;
		return -1;
	}

	ev->event_type = 0;
	memset(&v, 0, sizeof(struct pollfd));

	v.fd = lstnr.event_sock;
	v.events = POLLIN | POLLERR | POLLHUP;
	v.revents = 0;

	cc = poll(&v, 1, timeout);
	if (cc == 0)
		return 0;
	if (cc < 0) {
		errno = ENSTOP_NETIO;
		return -1;
	}

	if ((v.revents & POLLERR)
	    || (v.revents & POLLHUP)) {
		errno = ENSTOP_NETIO;
		return -1;
	}

	assert(v.revents & POLLIN);

	len = sizeof(struct sockaddr_in);
	s = accept(v.fd, (struct sockaddr *)&from, &len);
	if (s < 0) {
		if (lib_config->debug)
			smd_log_time(stderr, "\
%s: accept() on socket %d failed %s",  __func__, v.fd, strerror(errno));
		errno = ENSTOP_NETIO;
		return -1;
	}

	/* The controller protocol first sends us the
	 * size of the message then the message itself.
	 */
	cc = read(s, &size, sizeof(uint32_t));
	if (cc < 0) {
		if (lib_config->debug)
			smd_log_time(stderr, "\
%s: read() header failed %s",  __func__, strerror(errno));
		closeit(s);
		return -1;
	}

	/* The controller sends the size in network order.
	 */
	size = ntohl(size);

	/* We know the controller is sending us the callback_flags
	 * as uint32_t.
	 */
	cc = read(s, &event, sizeof(uint32_t));
	if (cc < 0) {
		if (lib_config->debug)
			smd_log_time(stderr, "\
%s: read() body failed %s",  __func__, strerror(errno));
		closeit(s);
		return -1;
	}

	ev->event_type = event;

	/* No event body for now.
	 */
	ev->event = NULL;
	switch (ev->event_type) {
		case SMD_EVENT_NODE_FAILED:
			ev->event_type = SMD_EVENT_NODE_FAILED;
			break;
		case SMD_EVENT_NODE_FAILING:
			ev->event_type = SMD_EVENT_NODE_FAILING;
			break;
		case SMD_EVENT_NODE_REPLACE:
			ev->event_type = SMD_EVENT_NODE_REPLACE;
			break;
		default:
			ev->event_type = -1;
			break;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: got event %d from controller",  __func__, ev->event_type);
	}

	closeit(s);
	errno = ENSTOP_OK;
	return ev->event_type;
}

/* smd_get_nonstopconfig()
 * Report nonstop plugin global state/configuration information
 */
extern int
smd_get_nonstopconfig(struct nonstop_config *config)
{
	smd_header_t hdr;
	char send_msg[MSG_SIZE];
	char key[128];
	char value[128];
	char *resp_msg;
	char *buf;
	int rc;
	int n;

	if (config == NULL) {
		errno = EINVAL;
		return -1;
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Invalid configuration detected.",  __func__);

		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	memset(config, 0, sizeof(struct nonstop_config));

	snprintf(send_msg, sizeof(send_msg), "SHOW_CONFIG");
	resp_msg = NULL;
	rc = _send_msg(send_msg, &resp_msg);
	if (rc < 0) {
		/* errno set in the IO layer
		 */
		freeit(resp_msg);
		return -1;
	}

	rc = _decode_header(&hdr, resp_msg);
	if (rc < 0) {
		freeit(resp_msg);
		return -1;
	}

	if (errno != ENSTOP_OK) {
		freeit(resp_msg);
		return -1;
	}

	/* buf now points somewhere in the middle
	 * of resp_msg, strdup() it if you want to
	 * keep it.
	 */
	buf = _decode_payload(&hdr, resp_msg);
	if (buf == NULL) {
		freeit(resp_msg);
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	while ((rc = sscanf(buf, "%s%s%n", key, value, &n)) == 2) {

		buf = buf + n;
		if (strcmp(key, "HotSpareCount") == 0) {
			config->hot_spare_count = strdup(value);
			continue;
		}
		if (strcmp(key, "MaxSpareNodeCount") == 0) {
			config->max_spare_node_count = atoi(value);
			continue;
		}
		if (strcmp(key, "TimeLimitDelay") == 0) {
			config->time_limit_delay = atoi(value);
			continue;
		}
		if (strcmp(key, "TimeLimitDrop") == 0) {
			config->time_limit_drop = atoi(value);
			continue;
		}
		if (strcmp(key, "TimeLimitExtend") == 0) {
			config->time_limit_extend = atoi(value);
			continue;
		}
		if (strcmp(key, "UserDrainAllow") == 0) {
			config->user_drain_allow = strdup(value);
			continue;
		}
		if (strcmp(key, "UserDrainDeny") == 0) {
			config->user_drain_deny = strdup(value);
			continue;
		}
		/* Ignore the parameters the library already
		 * has to know by configuration.
		 */
	}

	if (rc != EOF) {
		errno = ENSTOP_PROTOCOL;
		freeit(config->hot_spare_count);
		freeit(config->user_drain_allow);
		freeit(config->user_drain_deny);
		return -1;
	}

	/* Now copy the library specific configuration
	 * section.
	 */
	config->conf_fname = strdup(lib_config->conf_fname);
	config->control_addr = strdup(lib_config->control_addr);
	config->control_saddr = lib_config->control_saddr;
	if (lib_config->backup_addr)
		config->backup_addr = strdup(lib_config->backup_addr);
	config->backup_saddr = lib_config->backup_saddr;
	config->debug = lib_config->debug;
	config->port = lib_config->port;
	config->read_timeout = lib_config->read_timeout;
	config->write_timeout = lib_config->write_timeout;

	freeit(resp_msg);
	errno = ENSTOP_OK;

	return 0;
}

/* smd_free_nonstop_config()
 * Free the dynamic members of the config data structure.
 */
extern void
smd_free_nonstop_config(struct nonstop_config *conf)
{
	freeit(conf->conf_fname);
	freeit(conf->control_addr);
	freeit(conf->backup_addr);
	freeit(conf->hot_spare_count);
	freeit(conf->user_drain_allow);
	freeit(conf->user_drain_deny);
	/* Do not free conf as the user could
	 * could have allocated it on the stack.
	 */
}

/* smd_drop_node()
 */
extern int smd_drop_job_node(struct drop_node_request *request,
                             struct drop_node_reply *reply)
{
	smd_header_t hdr;
	char send_msg[MSG_SIZE];
	char key[128], value[MSG_SIZE];
	char *resp_msg;
	int n, rc;

	if (request == NULL
	    || request->node == NULL) {
		errno = EINVAL;
		return -1;
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr,
			             "%s: Invalid configuration detected.",
			             __func__);
		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "%s: job_id %u.",
		             __func__, request->job_id);
	}

	/* Build up the protocol message.
	 */
	snprintf(send_msg, sizeof(send_msg), "DROP_NODE:JOBID:%u:NODE:%s",
	         request->job_id, request->node);
	resp_msg = NULL;
	rc = _send_msg(send_msg, &resp_msg);
	if (rc < 0) {
		/* errno set in the IO layer
		 */
		return -1;
	}

	rc = _decode_header(&hdr, resp_msg);
	if (rc < 0) {
		freeit(resp_msg);
		return -1;
	}

	if (errno == ENSTOP_OK) {
		char *buf;

		reply->job_id = request->job_id;
		reply->node = strdup(request->node);
		reply->new_set.new_nodelist = NULL;
		reply->new_set.new_node_cnt = 0;
		reply->new_set.new_cpus_per_node = NULL;

		buf = _decode_payload(&hdr, resp_msg);
		if (buf == NULL) {
			freeit(resp_msg);
			errno = ENSTOP_PROTOCOL;
			return -1;
		}

		while ((rc = sscanf(buf, "%s%s%n", key, value, &n)) == 2) {
			buf = buf + n;
			if (strcmp(key, "NewNodeList") == 0) {
				reply->new_set.new_nodelist = strdup(value);
				continue;
			}
			if (strcmp(key, "NewNodeCount") == 0) {
				reply->new_set.new_node_cnt = atoi(value);
				continue;
			}
			if (strcmp(key, "NewCpusPerNode") == 0) {
				reply->new_set.new_cpus_per_node = strdup(value);
				continue;
			}
		}

		if (lib_config->debug) {
			smd_log_time(stderr,
			             "%s: NewNodeList=%s NewNodeCount=%d "
			             "NewCpusPerNode=%s",
			             __func__,
			             reply->new_set.new_nodelist,
			             reply->new_set.new_node_cnt,
			             reply->new_set.new_cpus_per_node);
		}
		freeit(resp_msg);
		return 0;
	}

	return -1;
}

/* smd_free_drop_job_node()
 */
extern void
smd_free_drop_job_node_reply(struct drop_node_reply *reply)
{
	freeit(reply->node);
	freeit(reply->new_set.new_nodelist);
	freeit(reply->new_set.new_cpus_per_node);
}

/* smd_nonstop_get_jobinfo()
 * Get information about a specific job from the controller.
 */
extern
int smd_nonstop_get_failed_jobinfo(struct job_nonstop_info_request *request,
                                   struct job_nonstop_info_reply *reply)
{
	smd_header_t hdr;
	char send_msg[MSG_SIZE];
	char *resp_msg;
	char *buf;
	int rc;
	int n;
	int cc;
	struct node_state *nodes;

	if (request== NULL
	    || request->job_id <= 0
	    || reply == NULL) {
		errno = EINVAL;
		return -1;
	}

	if (_read_config() < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Invalid configuration detected.",  __func__);
		}
		errno = ENSTOP_CONFIG;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: job_id %u.",  __func__, request->job_id);
	}

	/* Zero this out for the caller.
	 */
	memset(reply, 0, sizeof(struct job_nonstop_info_reply));
	reply->job_id = request->job_id;

	/* Build up the protocol message.
	 */
	snprintf(send_msg, sizeof(send_msg), "SHOW_JOB:JOBID:%u", request->job_id);

	resp_msg = NULL;
	rc = _send_msg(send_msg, &resp_msg);
	if (rc < 0) {
		/* errno set in the IO layer
		 */
		return -1;
	}

	/* Decode message header
	 */
	rc = _decode_header(&hdr, resp_msg);
	if (rc < 0) {
		freeit(resp_msg);
		return -1;
	}

	/* No nodes of the job has failed.
	 * The caller has to check the number
	 * failed nodes and if 0 ignore the
	 * rest of the reply data structure.
	 */
	if (errno == ENSTOP_NONODEFAIL) {
		freeit(resp_msg);
		return 0;
	}

	if (errno == ENSTOP_JOBID) {
		freeit(resp_msg);
		return 0;
	}

	/* buf now points somewhere in the middle
	 * of resp_msg, strdup() it if you want to
	 * keep it.
	 */
	buf = _decode_payload(&hdr, resp_msg);
	if (buf == NULL) {
		freeit(resp_msg);
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	/* Check how many failed nodes the job has.
	 */
	reply->job_id = request->job_id;
	rc = sscanf(buf, "%*s%u%n",  &reply->failed_node_cnt, &n);
	if (rc != 1) {
		freeit(resp_msg);
		errno = ENSTOP_PROTOCOL;
		return -1;
	}
	buf = buf + n;

	/* Allocate the corresponding number of node_state
	 * data structures.
	 */
	nodes = calloc(reply->failed_node_cnt, sizeof(struct node_state));
	if (nodes == NULL) {
		/* errno is set by the library call.
		 */
		freeit(resp_msg);
		return -1;
	}

	/* Decode the individual node state.
	 */
	for (cc = 0; cc < reply->failed_node_cnt; cc++) {
		/* Both calloc() and sscanf() must succeed in order
		 * to proceed. Set errno to 0 so we can distinguish
		 * what error happened.
		 */
		errno = 0;
		if (! (nodes[cc].node_name = calloc(MAXHOSTNAMELEN, sizeof(char *)))
		    || (rc = sscanf(buf, "%s%d%n", nodes[cc].node_name, &nodes[cc].cpu_cnt, &n)) != 2) {
			int i;
			for (i = 0; i < cc; i++)
				freeit(nodes[i].node_name);
			freeit(nodes);
			freeit(resp_msg);
			if (errno == 0)
				errno = ENSTOP_PROTOCOL;
			return -1;
		}
		nodes[cc].state = FAILED_NODES;
		buf = buf + n;
	}

	/* Set in the caller data structure.
	 */
	reply->failed_nodes = nodes;

	/* Decode the rest of the message from the controller.
	 */
	reply->pending_node_name = calloc(MAXHOSTNAMELEN, sizeof(char));
	if (reply->pending_node_name == NULL) {
		for (cc = 0; cc < reply->failed_node_cnt; cc++)
			freeit(nodes[cc].node_name);
		freeit(nodes);
		freeit(resp_msg);
		return -1;
	}

	rc = sscanf(buf, "\
%*s%u %*s%u %*s%s %*s%u %*s%u",	&reply->pending_job_delay,
	            &reply->pending_job_id, reply->pending_node_name,
	            &reply->replace_node_cnt, &reply->time_extend_avail);

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: job_id %u failed_node_cnt %u pend_job_delay %u pend_job_id %u \
pend_node_name %s replace_node_cnt %u time_extend_avail %u",
		             __func__,
		             reply->job_id, reply->failed_node_cnt,
		             reply->pending_job_delay, reply->pending_job_id,
		             reply->pending_node_name, reply->replace_node_cnt,
		             reply->time_extend_avail);
	}

	if (rc != 5 && rc != EOF) {
		freeit(reply->pending_node_name);
		freeit(resp_msg);
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	freeit(resp_msg);
	errno = ENSTOP_OK;

	return 0;
}

/* smd_nonstop_free_jobinfo()
 */
extern void
smd_nonstop_free_failed_jobinfo(struct job_nonstop_info_reply *r)
{
	int cc;

	freeit(r->pending_node_name);
	for (cc = 0; cc < r->failed_node_cnt; cc++)
		freeit(r->failed_nodes[cc].node_name);
	freeit(r->failed_nodes);
}

/* smd_nonstop_errstr()
 * Return the error string corresponding
 * to the errno.
 */
extern char *smd_nonstop_errstr(int errnum)
{
	int cc;

	if (errnum == 0)
		return nserrtab[ENSTOP_OK].msg;

	if (errnum < 1000)
		return strerror(errnum);

	for (cc = 0; cc < sizeof(nserrtab)/sizeof(nserrtab[0]); cc++) {
		if (errnum == nserrtab[cc].num)
			return nserrtab[cc].msg;
	}

	/* Unknow system message.
	 */
	return nserrtab[cc - 1].msg;
}

/* Free any memory allocated by libsmdns (optional)
 * If the multiple threads use the library only the
 * the last one should call this function otherwise
 * other thread will have serious memory problems.
 */
extern void smd_nonstop_fini(void)
{
	_free_config();
	errno = ENSTOP_OK;
}

/* Log a user supplied message.
 */
extern void
smd_log(FILE *fp, const char *fmt, ...)
{
	va_list args;

	pthread_mutex_lock(&log_lock);

	va_start(args, fmt);
	vfprintf(fp, fmt, args);
	fprintf(fp, "\n");
	va_end(args);

	pthread_mutex_unlock(&log_lock);
}

/* Log a user message preceded by the time
 * and threadID of the calling thread.
 */
extern void
smd_log_time(FILE *fp, const char *fmt, ...)
{
	va_list args;
	char buf[BUFSIZ2];

	pthread_mutex_lock(&log_lock);

	smd_time(buf);

	va_start(args, fmt);
	vsnprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), fmt, args);
	va_end(args);

	fprintf(fp, "%s\n", buf);

	pthread_mutex_unlock(&log_lock);
}

/* Print the current time and calling threadID
 */
extern char *
smd_time(char *buf)
{
	struct timeval now;
	char time_buf[TIMEBUFSIZ];

	gettimeofday(&now, NULL);
	ctime_r(&now.tv_sec, time_buf);

	sprintf(buf, "%.15s.%d %p ", time_buf + 4,
	        (int)now.tv_usec, (void *)pthread_self());

	return buf;
}

/* smd_match_key()
 */
int
smd_match_key(char *line, struct config_var *var)
{
	int cc;

	if (line == NULL
	    || var == NULL)
		return -1;

	cc = _matchKeys(line, var);

	return cc;
}

/* smd_get_next_token()
 */
char *
smd_get_token(char **line)
{
	static char buf[BUFSIZ];
	char *p = buf;

	while (isspace(**line))
		(*line)++;

	while (**line && !isspace(**line))
		*p++ = *(*line)++;

	if (p == buf)
		return NULL;

	*p = '\0';

	return buf;
}

/* The static helper functions.
 */

/* Malloc copy of in_str with all double quotes replaced by single quotes
 */
static char *_clean_str(const char *in_str)
{
	char *out_str;
	char *quote;

	if (in_str) {
		out_str = strdup(in_str);
	} else {
		out_str = calloc(1, sizeof(char));
		out_str[0] = '\0';
	}

	while ((quote = strchr(out_str, '"')))
		quote[0] = '\'';

	return out_str;
}

/* _read_config()
 *
 * Read nonstop.conf file.
 * RET 0 on success, -1 on error
 * Call _free_config to release allocated memory */
static int _read_config(void)
{
	char *slurm_conf_fname;
	char *nnstp_conf_fname;
	char *env;
	struct hostent *host;
	int cc;

	pthread_mutex_lock(&conf_lock);

	if (lib_config)
		goto cya;

	/* Allocate and initialize a clean data structure.
	 */
	lib_config = calloc(1, sizeof(struct nonstop_config));

	slurm_conf_fname = getenv("SLURM_CONF");
	if (slurm_conf_fname == NULL)
		slurm_conf_fname = default_slurm_config_file;

	/* This function returns a pointer
	 * to dynamic memory so no need to
	 * copy it again.
	 */
	nnstp_conf_fname = _get_config_file_name(slurm_conf_fname);

	/* First thing first... read the nonstop.conf
	 * file and build the auxiliary structure vars
	 * which represent the configuration file.
	 * vars is then copied into nonstop_config
	 * data structure used throughout the library,
	 * the reason for it is the library may want to
	 * add other specific variables to it which
	 * don't belong to vars.
	 */
	cc = _conf(nnstp_conf_fname, vars);
	if (cc < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: library failed to configure itself, exiting...",  __func__);
		}
		goto hosed;
	}

	/* Check debug first so we can enable it as
	 * first thing.
	 */
	if (vars[NONSTOP_DEBUG].val)
		lib_config->debug = atoi(vars[NONSTOP_DEBUG].val);

	/* Env overwrites config. Unix.
	 */
	if ((env = getenv("NONSTOP_DEBUG")))
		lib_config->debug = atoi(env);

	if (lib_config->debug) {
		smd_log_time(stderr, "%s: Reading configuration",  __func__);
	}

	lib_config->conf_fname = nnstp_conf_fname;

	/* The following are the variables concerning the
	 * library side of fault tollerant.
	 */
	if (vars[NONSTOP_CONTROLADDR].val)
		lib_config->control_addr = strdup(vars[NONSTOP_CONTROLADDR].val);
	if ((env = getenv("NONSTOP_CONTROLADDR")))
		lib_config->control_addr = strdup(env);


	if (vars[NONSTOP_BACKUPADDR].val)
		lib_config->backup_addr = strdup(vars[NONSTOP_BACKUPADDR].val);
	if ((env = getenv("NONSTOP_BACKUPADDR")))
		lib_config->backup_addr = strdup(env);

	if (vars[NONSTOP_PORT].val)
		lib_config->port = atoi(vars[NONSTOP_PORT].val);
	if ((env = getenv("NONSTOP_PORT")))
		lib_config->port = atoi(env);

	/* Set network I/O default timeouts, multiply
	 * by 1000 since we use poll() which has ms timeout.
	 */
	lib_config->read_timeout = lib_config->write_timeout = POLL_TIMEOUT;
	if (vars[NONSTOP_READTIMEOUT].val)
		lib_config->read_timeout = atoi(vars[NONSTOP_READTIMEOUT].val) * 1000;
	if ((env = getenv("NONSTOP_READTIMEOUT")))
		lib_config->read_timeout = atoi(env);

	if (vars[NONSTOP_WRITETIMEOUT].val)
		lib_config->write_timeout = atoi(vars[NONSTOP_WRITETIMEOUT].val) * 1000;
	if ((env = getenv("NONSTOP_WRITETIMEOUT")))
		lib_config->write_timeout = atoi(env);

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: Library parameters of %s",  __func__, lib_config->conf_fname);
		if (lib_config->control_addr)
			smd_log_time(stderr, "\
%s: ControlAddr=%s",  __func__, lib_config->control_addr);
		if (lib_config->backup_addr)
			smd_log_time(stderr, "\
%s: BackupAddr=%s",  __func__, lib_config->backup_addr);
		if (lib_config->debug)
			smd_log_time(stderr, "\
%s: Debug=%hu",  __func__, lib_config->debug);
		if (lib_config->port)
			smd_log_time(stderr, "\
%s: Port=%hu",  __func__, lib_config->port);
		if (lib_config->read_timeout)
			smd_log_time(stderr, "\
%s: ReadTimeout=%u",  __func__, lib_config->read_timeout);
		if (lib_config->write_timeout)
			smd_log_time(stderr, "\
%s: WriteTimeout=%u",  __func__, lib_config->write_timeout);
	}

	/* Free the library working
	 * structure.
	 */
	cc = 0;
	while (vars[cc].val) {
		freeit(vars[cc].val);
		++cc;
	}

	if (lib_config->port == 0
	    || lib_config->control_addr == NULL) {
		smd_log_time(stderr, "\
%s: Invalid configuration in %s",  __func__, lib_config->conf_fname);
		goto hosed;
	}

	/* Get the IPv4 address of the main server.
	 */
	host = gethostbyname(lib_config->control_addr);
	if (host == NULL) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Unknown ControlAddr: %s in %s",  __func__,
			             lib_config->control_addr, lib_config->conf_fname);
		}
		goto hosed;
	}

	memcpy(&lib_config->control_saddr, host->h_addr, sizeof(in_addr_t));

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: Primary controller IP %s.",
		             __func__, inet_ntoa(*(struct in_addr *)&lib_config->control_saddr));
	}

	/* and the backup controller if configured.
	 */
	if (lib_config->backup_addr) {
		host = gethostbyname(lib_config->backup_addr);
		if (host == NULL) {
			if (lib_config->debug) {
				smd_log_time(stderr, "\
%s: Unknown BackupAddr %s in %s",  __func__, lib_config->backup_addr,
				             lib_config->conf_fname);
			}
			goto hosed;
		}

		memcpy(&lib_config->backup_saddr, host->h_addr, sizeof(in_addr_t));

		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: Backup controller IP %s",  __func__,
			             inet_ntoa(*(struct in_addr *)&lib_config->backup_saddr));
		}
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "%s: configuration read all right",  __func__);
	}

	/* Initialiaze the event listener socket to
	 * an invalid socket number.
	 */
	lstnr.event_sock = -1;

cya:
	pthread_mutex_unlock(&conf_lock);
	return 0;

hosed:
	errno = ENSTOP_CONFIG;
	pthread_mutex_unlock(&conf_lock);
	return -1;
}

/* _free_config()
 *
 * Free memory allocated by _read_config().
 * This can be used at the application termination to check
 * for memory leaks, but would not normally be used.
 */
static void _free_config(void)
{
	pthread_mutex_lock(&conf_lock);
	freeit(lib_config->conf_fname);
	freeit(lib_config->control_addr);
	freeit(lib_config->backup_addr);
	lib_config->control_saddr = lib_config->backup_saddr = 0;
	lib_config->debug = lib_config->port = 0;
	pthread_mutex_unlock(&conf_lock);
	pthread_mutex_destroy(&conf_lock);
	/* At last free the configuration
	 * pointer and set it to NULL.
	 */
	freeit(lib_config);
}

/* _write_bytes()
 * Make sure the socket is writable and then write.
 */
static int _write_bytes(int fd, char *msg, int msg_size)
{
	int i, rc = 0, offset = 0, sent;
	struct pollfd poll_fds;

	while (msg_size > offset) {
		poll_fds.fd = fd;
		poll_fds.events = POLLOUT;
		poll_fds.revents = 0;
		i = poll(&poll_fds, 1, lib_config->write_timeout);
		if (i == -1) {
			if ((errno == EAGAIN) || (errno == EINTR))
				continue;
			if (lib_config->debug) {
				smd_log_time(stderr, "\
%s: poll() error: %s",  __func__, strerror(errno));
			}
			rc = -1;
		} else if (i == 0) {
			if (lib_config->debug)
				smd_log_time(stderr, "\
%s: poll() timeout bail out",  __func__);
			rc = -1;
			break;
		}

		sent = write(fd, msg + offset, msg_size - offset);
		if (sent > 0) {
			offset += sent;
		} else if (sent == 0) {
			if (lib_config->debug)
				smd_log_time(stderr, "\
%s: write() returned EOF %s bail out",  __func__, strerror(errno));
			rc = -1;
			break;
		} else if ((errno != EAGAIN) && (errno != EINTR)) {
			if (lib_config->debug) {
				smd_log_time(stderr, "\
%s: write() error: %s",  __func__, strerror(errno));
			}
			rc = -1;
			break;
		}
	}
	return rc;
}
/* _ns_write()
 * Write header and payload.
 */
static int _ns_write(int fd, char *msg)
{
	int rc = 0;
	char header[16];
	uint32_t msg_size = 0;

	msg_size = strlen(msg) + 1;
	sprintf(header, "%08u\n", msg_size);
	rc = _write_bytes(fd, header, 9);
	if (rc == 0)
		rc = _write_bytes(fd, msg, msg_size);
	return rc;
}

/* _read_bytes()
 * Wait for the socket to be readable and read it.
 */
static int _read_bytes(int fd, char *msg, int msg_size)
{
	int i, rc = 0, offset = 0, recv;
	struct pollfd poll_fds;

	while (msg_size > offset) {
		poll_fds.fd = fd;
		poll_fds.events = POLLIN;
		poll_fds.revents = 0;
		i = poll(&poll_fds, 1, lib_config->read_timeout);
		if (i == -1) {
			if ((errno == EAGAIN) || (errno == EINTR))
				continue;
			if (lib_config->debug) {
				smd_log_time(stderr, "\
%s: poll() error: %s",  __func__, strerror(errno));
			}
			rc = -1;
			errno = ENSTOP_NETIO;
		} else if (i == 0) {
			if (lib_config->debug)
				smd_log_time(stderr, "\
%s: poll() timeout bail out",  __func__);
			rc = -1;
			errno = ENSTOP_NETIO;
			break;
		}

		recv = read(fd, msg + offset, msg_size - offset);
		if (recv > 0) {
			offset += recv;
		} else if (recv == 0) {
			if (lib_config->debug) {
				smd_log_time(stderr, "\
%s: read() returned EOF %s bail out",  __func__, strerror(errno));
			}
			rc = -1;
			errno = ENSTOP_NETIO;
			break;
		} else if ((errno != EAGAIN) && (errno != EINTR)) {
			if (lib_config->debug) {
				smd_log_time(stderr, "\
%s: read() error: %s",  __func__, strerror(errno));
			}
			rc = -1;
			errno = ENSTOP_NETIO;
			break;
		}
	}
	return rc;
}

/* _ns_read()
 * Read the header and the payload.
 * Note: Caller must free non-null resp value
 */
static int _ns_read(int fd, char **resp)
{
	int rc;
	char header[16], *msg;
	unsigned long msg_size = 0;

	*resp = NULL;
	memset(&header, 0, sizeof(header));
	/* Read and scan the transport header.
	 */
	if (_read_bytes(fd, header, 9))
		return -1;

	if (sscanf(header, "%lu", &msg_size) != 1) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: malformed message header (%s)",  __func__,
			             header);
		}
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	if (msg_size > MAX_MSG_SIZE) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: invalid message size (%lu) MAX_MSG_SIZE %d ",
			             __func__, msg_size, MAX_MSG_SIZE);
		}
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	msg = calloc(msg_size, sizeof(char));
	if (!msg) {
		if (lib_config->debug)  {
			smd_log_time(stderr, "\
%s: calloc() failed %s",  __func__, strerror(errno));
		}
		return -1;
	}
	rc = _read_bytes(fd, msg, msg_size);
	if ((rc == 0) && lib_config->debug) {
		smd_log_time(stderr, "\
%s: got message %s size %lu ",  __func__,
		             msg, msg_size);
	}
	*resp = msg;

	return rc;
}

/* _encrypt()
 *
 * fork() and call munge command. The caller has to
 * be aware the library forks in case uses threads.
 */
static char *_encrypt(char *msg)
{
	int msg_size, status;
	int pfdout[2], pfdin[2];
	pid_t pid;
	char *resp = NULL;

	if ((pipe(pfdout) < 0) || (pipe(pfdin) < 0)) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: pipe() error: %s",  __func__, strerror(errno));
		}
		return NULL;
	}

	msg_size = strlen(msg) + 1;

	/* Ohmygosh fork() doesnt work...
	 */
	pid = fork();
	if (pid < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: fork() error: %s",  __func__, strerror(errno));
		}
		close(pfdin[0]);
		close(pfdin[1]);
		return NULL;
	}

	/* Child runs munge
	 */
	if (pid == 0) {
		dup2(pfdin[1],  1);
		dup2(pfdout[0], 0);
		close(pfdin[0]);
		close(pfdin[1]);
		close(pfdout[0]);
		close(pfdout[1]);
		execlp("munge", "munge", NULL);
		exit(1);
	}

	/* Parent write to the child command munge
	 * to encrypt the message
	 */
	_write_bytes(pfdout[1], msg, msg_size);
	close(pfdout[0]);
	close(pfdout[1]);
	msg_size += 2048;
	resp = calloc(msg_size, sizeof(char));

	/* Read the encrypted message from munge.
	 */
	if (read(pfdin[0], resp, msg_size) < 0) {
		if (lib_config->debug) {
			smd_log_time(stderr, "\
%s: encrypt read() error: %s",  __func__, strerror(errno));
		}
		free(resp);
		close(pfdin[0]);
		close(pfdin[1]);
		return NULL;
	}
	/* Close the pipes and wait for our child.
	 * If child hangs we hang.
	 */
	close(pfdin[0]);
	close(pfdin[1]);
	/* TO DO: wait for a given period of time.
	 */
	waitpid(pid, &status, 0);

	return resp;
}

/* _send_msg()
 * Send a message to the controller. The message is
 * encrypted by munge.
 */
static int _send_msg(char *msg, char **resp)
{
	int fd = -1;
	int rc = 0;
	int cc;
	struct sockaddr_in serv_addr;
	char *munge_str;
	in_addr_t addr[2];

	if (resp == NULL || msg == NULL || *msg == 0) {
		errno = EINVAL;
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "%s: sending message %s to controller.",
		             __func__, msg);
	}

	/* Try to connect to the controller or its backup.
	 */
	addr[0] = lib_config->control_saddr;
	addr[1] = lib_config->backup_saddr;
	cc = 0;
	do {
		if ((fd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
			if (lib_config->debug) {
				smd_log_time(stderr, "%s: socket error: %s",
				             __func__, strerror(errno));
			}
			return -1;
		}

		if (lib_config->debug) {
			smd_log_time(stderr,
			             "%s: trying to connect() to %s", __func__,
			             inet_ntoa(*(struct in_addr *)&addr));
		}

		memset(&serv_addr, 0, sizeof(serv_addr));
		serv_addr.sin_family = AF_INET;
		serv_addr.sin_addr.s_addr = addr[cc];
		serv_addr.sin_port = htons(lib_config->port);
		while (connect(fd, (struct sockaddr *) &serv_addr,
		               sizeof(serv_addr)) < 0) {
			if ((errno == EAGAIN) || (errno == EINTR))
				continue;
			if (lib_config->debug) {
				smd_log_time(stderr,
				             "%s: connect() error %s",
				             __func__, strerror(errno));
			}
			closeit(fd);
			return -1;
		}
		++cc;

	} while (cc < 2 && fd < 0);

	if (fd < 0) {
		closeit(fd);
		/* The errno is set by the failing connect().
		 */
		if (lib_config->debug) {
			smd_log_time(stderr,
			             "%s: connect() failed %s",
			             __func__, strerror(errno));
		}
		return -1;
	}

	/* fork() and exec munge command to
	 * encrypt the message.
	 */
	munge_str = _encrypt(msg);
	if (munge_str == NULL) {
		close(fd);
		errno = ENSTOP_NETIO;
		if (lib_config->debug) {
			smd_log_time(stderr, "%s: encryption error.",
			             __func__);
		}
		return -1;
	}

	/* Write header and payload.
	 */
	rc = _ns_write(fd, munge_str);
	if (rc < 0) {
		/* errno set inside the function.
		 */
		free(munge_str);
		close(fd);
		if (lib_config->debug) {
			smd_log_time(stderr, "%s: _ns_write() error %s",
			             __func__, strerror(errno));
		}
		return -1;
	}
	free(munge_str);

	/* Read header and payload.
	 */
	rc = _ns_read(fd, resp);
	if (rc < 0) {
		/* errno set inside the function.
		 */
		close(fd);
		if (lib_config->debug) {
			smd_log_time(stderr, "%s: _ns_read() error %s",
			             __func__, strerror(errno));
		}
		return -1;
	}

	if (lib_config->debug) {
		smd_log_time(stderr, "%s: message to controller sent.",
		             __func__);
	}

	return 0;
}

/* _conf()
 */
static int
_conf(const char *file,
      struct config_var *v)
{
	FILE *fp;
	char *p;
	struct stat sbuf;
	char *buf;
	int cc;

	if (!file)
		return -1;

	fp = fopen(file, "r");
	if (fp == NULL) {
		return -1;
	}

	cc = stat(file, &sbuf);
	if (cc < 0)
		return -1;

	/* We have faith in memory allocation.
	 */
	buf =  calloc(sbuf.st_size, sizeof(char *));

	while ((p = _nextline(fp, buf, sbuf.st_size))) {
		_matchKeys(p, v);
	}
	free(buf);
	fclose(fp);

	return 0;

} /* _conf() */

/* Get the next meaningful line from the configuration
 * file, meaningful is a line that is not isspace()
 * and that does not start with a comment # character.
 * Remove trailing # as well.
 */
static char *
_nextline(FILE *fp, char *buf, int l)
{
	char *p;
	char *c;

	p = NULL;
	while (fgets(buf, l, fp)) {
		p = buf;
		_chop(p);
		while (isspace(*p))
			++p;
		if (*p == '#'
		    || *p == 0) {
			/* If this is the last or only
			 * line do not return the
			 * previous buffer to the caller.
			 */
			p = NULL;
			continue;
		}
		break;
	}

	if (p && (c = strchr(p, '#')))
		*c = 0;

	return p;

} /* _nextline() */

/* _chop() away the \n
 * Perl?
 */
static char *
_chop(char *z)
{
	int L;

	L = strlen(z);
	z[L - 1] = 0;

	return z;

} /* _chop() */

/* _matchKeys()
 * Given a line from the configuration file,
 * match the configuration key.
 */
static int
_matchKeys(char *p,
           struct config_var *v)
{
	int	i;
	char   *eq;
	char   *p2;

	i = 0;
	p2 = NULL;
	while (v[i].key) {
		if ((p2 = strstr(p, v[i].key))) {
			break;
		}
		++i;
	}

	if (!p2)
		return -1;

	eq = strchr(p, '=');
	if (eq) {
		++eq;
		while (isspace(*eq))
			++eq;
		v[i].val = strdup(eq);
		assert(v[i].val);
	}

	return(0);

} /* _matchKeys() */

/* get_config_file_name(char *file);
 * From /the/path/slurm.conf return
 * /the/path/nonstop.conf
 */
static char *
_get_config_file_name(char *file)
{
	char *p;
	char *nonstop = "nonstop.conf";
	char *myfile;
	char *file0;
	int l;

	file0 = strdup(file);

	p = strrchr(file0, '/');
	if (p == NULL)
		return strdup(nonstop);

	*p = 0;
	/* /usr/local/etc/nonstop.conf */
	l = strlen(file0) + 1 + strlen(nonstop) + 1;
	myfile = calloc(l, sizeof(char));
	sprintf(myfile, "%s/%s", file0, nonstop);

	freeit(file0);

	return myfile;
}

/* _decode_header()
 *
 * Read the versionn number and the header from
 * the controller and map it to a library error
 * number. ENOERROR indicates no error happens.
 * The message can carry additional payload that
 * will be decoded by the caller.
 */
static int
_decode_header(smd_header_t *hdr, const char *msg)
{
	int cc;

	if (msg == NULL
	    || hdr == NULL) {
		errno = EINVAL;
		return -1;
	}

	cc = sscanf(msg, "%s%s", hdr->version, hdr->opcode);
	if (cc == EOF
	    || cc != 2) {
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	/* Now map the header opcode received from
	 * the controller to the library errno
	 * enum. Mapping messages from the controller
	 * to library errno allows us to eventually
	 * change the daemon protocol but don't change
	 * the library interface to user.
	 */
	if (strcmp(hdr->opcode, "ENOERROR") == 0)
		errno = ENSTOP_OK;
	else if (strcmp(hdr->opcode, "ECMD") == 0)
		errno = ENSTOP_INVALCMD;
	else if (strcmp(hdr->opcode, "EUPDNODE") == 0)
		errno = ENSTOP_UPNODE;
	else if (strcmp(hdr->opcode, "EJOBID") == 0)
		errno = ENSTOP_JOBID;
	else if (strcmp(hdr->opcode, "EPERM") == 0)
		errno = EPERM;
	else if (strcmp(hdr->opcode, "EPORT") == 0)
		errno = ENSTOP_PORT;
	else if (strcmp(hdr->opcode, "EUID") == 0)
		errno = ENSTOP_UID;
	else if (strcmp(hdr->opcode, "EJOBNOTRUN") == 0)
		errno = ENSTOP_JOBNOTRUN;
	else if (strcmp(hdr->opcode, "ENOHOST") == 0)
		errno = ENSTOP_NOHOST;
	else if (strcmp(hdr->opcode, "ENODEFAIL") == 0)
		errno = ENSTOP_NODENOTFAILED;
	else if (strcmp(hdr->opcode, "ENODENOTINJOB") == 0)
		errno = ENSTOP_NODENOTINJOB;
	else if (strcmp(hdr->opcode, "EREPLACELATER") == 0)
		errno = ENSTOP_REPLACELATER;
	else if (strcmp(hdr->opcode, "EREPLACEPENDING") == 0)
		errno = ENSTOP_REPLACEPENDING;
	else if (strcmp(hdr->opcode, "EMAXSPARECOUNT") == 0)
		errno = ENSTOP_MAXSPARECOUNT;
	else if (strcmp(hdr->opcode, "ENODEREPLACEFAIL") == 0)
		errno = ENSTOP_NODEREPLACEFAILED;
	else if (strcmp(hdr->opcode,"ENOINCREASETIMELIMIT") == 0)
		errno = ENSTOP_NOINCREASETIMELIMIT;
	else if (strcmp(hdr->opcode, "ETIMEOVERLIMIT") == 0)
		errno = ENSTOP_TIMEOVERLIMIT;
	else if (strcmp(hdr->opcode, "EJOBUPDATE") == 0)
		errno = ENSTOP_JOBUPDATE;
	else if (strcmp(hdr->opcode, "ENODENOTFAIL") == 0)
		errno = ENSTOP_NONODEFAIL;
	else
		errno = ENSTOP_UNKWNCTRLMSG;

	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: header decoded version %s opcode %s",  __func__, hdr->version, hdr->opcode);
	}

	return 0;
}

/* _decode_payload()
 * Return the pointer to the data part
 * of the message received from the controller.
 * The returned pointer is strdup().
 */
static char *
_decode_payload(smd_header_t *hdr, char *msg)
{
	char *p;
	int n;

	if (msg[0] == 0)
		return NULL;

	p = msg;

	/* Skip the version number and the
	 * header returning only the body.
	 */
	sscanf(p, "%s%s%n", hdr->version, hdr->opcode, &n);
	if (lib_config->debug) {
		smd_log_time(stderr, "\
%s: payload decoded %s", __func__, p);
	}
	p = p + n;

	/* p points in the middle of msg
	 * the caller must dup it if wants
	 * to keep it since the library will
	 * free the original msg.
	 */
	return p;
}

/* _count_ntuples()
 * Given a char buffer count of how many
 * ntuples it is made.
 */
static int
_count_ntuples(char *buf, int n)
{
	char a[BUFSIZ2];
	char b[BUFSIZ2];
	char c[BUFSIZ2];
	int num;
	int nelem;
	int cc;

	nelem = 0;
	while ((cc = sscanf(buf, "%s%s%s%n", a, b, c, &num)) == n) {
		++nelem;
		buf = buf + num;
	}

	/* If we reached the end of the string sscanf()
	 * must return us EOF otherwise we read less than
	 * n characters indicating a string format error.
	 */
	if (cc != EOF) {
		errno = ENSTOP_PROTOCOL;
		return -1;
	}

	return nelem;
}

/* Tools
 */
/* Simple double linked list.
 * The idea is very simple we have 2 insertion methods
 * enqueue which adds at the end of the queue and push
 * which adds at the front. Then we simply pick the first
 * element in the queue. If you have inserted by enqueue
 * you get a FCFS policy if you pushed you get a stack policy.
 *
 *
 * FCFS
 *
 *   H->1->2->3->4
 *
 * you retrive elements as 1, 2 etc
 *
 * Stack:
 *
 * H->4->3->2->1
 *
 * you retrieve elements as 4,3, etc
 *
 *
 */

struct list_ *
listmake(const char *name)
{
    struct list_   *L;

    L = calloc(1, sizeof(struct list_));
    assert(L);
    L->forw = L->back = L;

    L->name = strdup(name);
    assert(L->name);

    return L;

} /* listmake() */

/* listinisert()
 *
 * Using cartesian coordinates the head h is at
 * zero and elemets are pushed along x axes.
 *
 *       <-- back ---
 *      /             \
 *     h <--> e2 <--> e
 *      \             /
 *        --- forw -->
 *
 * The h points the front, the first element of the list,
 * elements can be pushed in front or enqueued at the back.
 *
 */
int
listinsert(struct list_ *h,
           struct list_ *e,
           struct list_ *e2)
{
    assert(h && e && e2);

    /*  before: h->e
     */

    e->back->forw = e2;
    e2->back = e->back;
    e->back = e2;
    e2->forw = e;

    /* after h->e2->e
     */

    h->num++;

    return h->num;

} /* listinsert() */

/*
 * listenqueue()
 *
 * Enqueue a new element at the end
 * of the list.
 *
 * listenque()/listdeque()
 * implements FCFS policy.
 *
 */
int
listenque(struct list_ *h,
          struct list_ *e2)
{
    assert(h && e2);

    /* before: h->e
     */
    listinsert(h, h, e2);
    /* after: h->e->e2
     */
    return 0;
}

/* listdeque()
 */
struct list_ *
listdeque(struct list_ *h)
{
    struct list_   *e;

    if (h->forw == h) {
        assert(h->back == h);
        return(NULL);
    }

    /* before: h->e->e2
     */

    e = listrm(h, h->forw);

    /* after: h->e2
     */

    return e;
}

/*
 * listpush()
 *
 * Push e at the front of the list
 *
 * H --> e --> e2
 *
 */
int
listpush(struct list_ *h,
         struct list_ *e2)
{
    /* before: h->e
     */
    listinsert(h, h->forw, e2);

    /* after: h->e2->e
     */

    return 0;
}

/* listpop()
 */
struct list_ *
listpop(struct list_ *h)
{
    struct list_ *e;

    e = listdeque(h);

    return e;
}

/* listrm()
 */
struct list_ *
listrm(struct list_ *h,
       struct list_ *e)
{
    if (h->num == 0)
        return(NULL);

    e->back->forw = e->forw;
    e->forw->back = e->back;
    h->num--;

    return e;

} /* listrm() */


/* listfree()
 */
void
listfree(struct list_ *L,
         void (*f)())
{
    struct list_ *l;
    struct liste *e;

    while ((l = listpop(L))) {

	    e = (struct liste *)l;
        if (f == NULL)
            free(l);
        else
            (*f)(e->data);

        list_element_free(e);
    }

    free(L->name);
    free(L);
}

/* list_element_free()
 */
void
list_element_free(struct liste *e)
{
	if (e == NULL)
		return;

	freeit(e);
}

/* millisleep_()
 */
int
millisleep_(int ms)
{
	struct timespec ts;
	struct timespec tr;
	int cc;
	int s;
	double frac;

	s = ms / 1000;
	frac = (double)ms - (double)(s * 1000.0);

	ts.tv_sec = s;
	ts.tv_nsec = (int)frac * 1000;

#if 0
	printf("\
s:%d frac:%f tv_sec:%ld tv_usec:%ld \n", s, frac, ts.tv_sec, ts.tv_nsec);
#endif

znovu:
	cc = nanosleep(&ts, &tr);
	if (cc < 0) {
		if (errno == EINTR) {
			memcpy(&ts, &tr, sizeof(struct timespec));
			goto znovu;
		}
		return -1;
	}

	return 0;
}
