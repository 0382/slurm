<!--#include virtual="header.txt"-->

<h1>Slurm REST API</h1>

<p>Slurm provides a
	<a href="https://en.wikipedia.org/wiki/Representational_state_transfer">
		REST API
	</a> daemon named slurmrestd. This daemon is designed to allow clients to
	communicate with Slurm via a REST API (in addition to the command line
	interface (CLI) or C API).
</p>
<p>Please see <a href="rest_release_notes.html">REST API Release Notes</a> for
changes between release versions.</p>
<p>
	To view the currently generated API reference:
	<a href="rest_api.html">Slurm REST API Reference</a>
</p>

<h2 id="prereq">Prerequisites<a class="slurm_link" href="#prereq"></a></h2>
<p>slurmrestd requires additional libraries for compilation:</p>
<ul>
	<li><a href="download.html#httpparser">HTTP Parser</a> (>= v2.6.0)</li>
	<li><a href="download.html#yaml">LibYAML</a> (optional)</li>
	<li><a href="download.html#json">JSON-C</a></li>
	<li><a href="download.html#jwt">JWT Authentication</a> (optional)</li>
</ul>

<h2 id="stateless">Stateless<a class="slurm_link" href="#stateless"></a></h2>
<p>Slurmrestd is stateless as it does not cache or save any state between
requests. Each request is handled in a thread and then all of that state is
discarded. Any request to slurmrestd is completely synchronous with the
Slurm controller (slurmctld or slurmdbd) and is only considered complete once
the HTTP response code has been sent to the client. Slurmrestd will hold a
client connection open while processing a request. Slurm database commands are
commited at the end of every request, on the success of all API calls in the
request.</p>
<p>Sites are strongly encouraged to setup a caching proxy between slurmrestd
and clients to avoid having clients repeatedly call queries, causing usage to
be higher than needed (and causing lock contention) on the controller.</p>

<h2 id="run_modes">Run modes<a class="slurm_link" href="#run_modes"></a></h2>
<p>Slurmrestd currently supports two run modes: inet service mode and listening
mode.</p>

<h3 id="inet">Inet Service Mode<a class="slurm_link" href="#inet"></a></h3>
<p>The Slurmrestd daemon acts as an
<a href="https://en.wikipedia.org/wiki/Inetd">
	Inet Service
</a> treating STDIN and STDOUT as the client. This mode allows clients to use
inetd, xinetd, or systemd socket activated services and avoid the need to run a
daemon on the host at all times. This mode creates an instance for each client
and does not support reusing the same instance for different clients.</p>

<h3 id="listen">Listening Mode<a class="slurm_link" href="#listen"></a></h3>
<p>The Slurmrestd daemon acts as a full UNIX service and continuously listens
for new TCP connections. Each connection and request are independently
authenticated.</p>

<h2 id="config">Configuration<a class="slurm_link" href="#config"></a></h2>
slurmrestd can be configured either by environment variables or command line
arguments. Please see the <b>doc/man/man1/slurmrestd.1</b> man page for details.

<h2 id="ipv6">IPv6 Support<a class="slurm_link" href="#ipv6"></a></h2>
<p>Slurmrestd supports IPv6 clients. On dual stack systems,
it will likely provide the source IP as an
<a href="https://en.wikipedia.org/wiki/IPv6#IPv4-mapped_IPv6_addresses">
	IPv6 IP for IPv4 clients
</a>. Slurmrestd must still be able to talk to slurmctld and slurmdbd via
IPv4.</p>

<h2 id="openapi">OpenAPI Specification (OAS)
<a class="slurm_link" href="#openapi"></a>
</h2>
<p>Slurmrestd is compliant with
	<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md">
		OpenAPI 3.0.2
	</a>.
	The OAS can be viewed at the following URLs:
</p>
<ul>
	<li>/openapi.json</li>
	<li>/openapi.yaml</li>
	<li>/openapi/v3</li>
</ul>
<p>The OAS is designed to be the primary documentation for the request methods.
There are several third party tools that automatically generate documentation
against the OAS output listed by
<a href="https://openapi.tools/">openapi.tools.</a></p>

<p><b>NOTE:</b> Slurm attempts to strictly comply with the relevant
<a href="https://github.com/OAI/OpenAPI-Specification">OpenAPI standards</a>.
For reasons of compatibility, Slurm may be tested against publicly available
OpenAPI client generators, but Slurm does not directly support any of them as
they are outside the control of SchedMD and may change at anytime. The goal
is to comply with the standards, supporting as many clients as possible,
without favoring any one client. Sites are always welcome to write their own
clients that are OpenAPI compliant. As a rule, SchedMD will debug the HTTP
sent to and received by slurmrestd but will not directly debug any client
source code.
</p>
Tested compatibility by OpenAPI plugins:
<ul>
	<li>openapi/v0.0.35:
		<ul>
			<li>
				<a href="https://github.com/OpenAPITools/openapi-generator">
					v4.x of OpenAPI-generator
				</a>
			</li>
		</ul>
	</li>
	<li>openapi/v0.0.36:
		<ul>
			<li>
				<a href="https://github.com/OpenAPITools/openapi-generator">
					v4.x of OpenAPI-generator
				</a>
			</li>
		</ul>
	</li>
	<li>openapi/v0.0.37:
		<ul>
			<li>
				<a href="https://github.com/OpenAPITools/openapi-generator">
					v4.x of OpenAPI-generator
				</a>
			</li>
			<li>
				<a href="https://github.com/OpenAPITools/openapi-generator">
					v5.x of OpenAPI-generator
				</a>
			</li>
		</ul>
	</li>
	<li>openapi/dbv0.0.36:
		<ul>
			<li>
				<a href="https://github.com/OpenAPITools/openapi-generator">
					v4.x of OpenAPI-generator
				</a>
			</li>
		</ul>
	</li>
	<li>openapi/dbv0.0.37:
		<ul>
			<li>
				<a href="https://github.com/OpenAPITools/openapi-generator">
					v4.x of OpenAPI-generator
				</a>
			</li>
			<li>
				<a href="https://github.com/OpenAPITools/openapi-generator">
					v5.x of OpenAPI-generator
				</a>
			</li>
		</ul>
	</li>
</ul>

<h2 id="plugins">Plugins<a class="slurm_link" href="#plugins"></a></h2>
<p>As of Slurm 20.11, the REST API uses plugins for authentication and
generating content. These plugins can be optionality listed or selected via
command line arguments as described in the <a href="slurmrestd.html">
slurmrestd</a> documentation.</p>

<h3 id="lifecycle">Plugin life cycle
<a class="slurm_link" href="#lifecycle"></a>
</h3>
<p>Plugins provided with Slurm in any release are considered supported by that
release. Due to the nature of the plugins, one plugin can be supported accross
multiple Slurm releases to ensure (limited) forward client compatibility. As
the slurmrestd plugins are relatively new, we are currently only explicitly
deprecating plugins and expect any plugin not marked for deprecation to
continue to exist in the next Slurm release. When a plugin is marked for
removal in the next major Slurm release, the OpenAPI specification dictates
that the given plugin will have all of the paths tagged with
<pre>"deprecated": "true"</pre></p>

<p>Sites are <b>always</b> encouraged to use the latest stable plugin version
available for code development. There is <b>no</b> guarantee of compatibility
between different versions of the same plugin with clients. Clients should
always make sure to validate their code when migrating to newer versions of
plugins. Plugin versions will always be included in the path for every method
provided by a given plugin to ensure no two plugins will provide the same
path.</p>

<p>As the plugins utilize the Slurm API internally, plugins that existed in
previous versions of Slurm should continue to be able to communicate with the
two previous versions of Slurm, similar to other components of Slurm. Newer
plugins may have required RPC changes which will exclude them from working with
previous Slurm versions. For instance, the openapi/dbv0.0.36 plugin will not be
able to communicate with any slurmdbd servers prior to the slurm-20.11
release.</p>

<p>As with all other plugins in Slurm, sites are more than welcome to write
their own plugins and are suggested to submit them as code contributions via
<a href="https://bugs.schedmd.com/">bugzilla</a>, tagged as a contribution.
The plugin API provided may change between releases which could cause site
specific plugins to break.</p>

<h2 id="security">Security<a class="slurm_link" href="#security"></a></h2>
<p>The Slurm REST API is written to provide the necessary functionality for
clients to control Slurm using REST commands. It is <b>not</b> designed to be
directly internet facing.  Only unencrypted and uncompressed HTTP
communications are supported. Slurmrestd also has no protection against man in
the middle or replay attacks. Slurmrestd should only be placed in a trusted
network that will communicate with a trusted client.</p>

<h2 id="jwt">JSON Web Token (JWT) Authentication
<a class="slurm_link" href="#jwt"></a>
</h2>
<p>slurmrestd supports using <a href=jwt.html>JWT to authenticate users</a>.
JWT can be used to authenticate user over REST protocol.
<ul>
	<li>User Name Header: X-SLURM-USER-NAME</li>
	<li>JWT Header: X-SLURM-USER-TOKEN</li>
</ul>
SlurmUser or root can provide alternative user names to act as a proxy for the
given user. While using JWT authentication, slurmrestd should be run as a
unique, <b>unprivileged</b> user and group. Slurmrestd should be provided an
invalid SLURM_JWT environment variable at startup to activate JWT authentication.
This will allow users to provide their own JWT tokens while authenticating to
the proxy and ensuring against any possible accidental authorizations.</p>
<p>When using JWT, it is important that <u>AuthAltTypes=auth/jwt</u> be
configured in your slurm.conf for slurmrestd.</p>

<h2 id="local_auth">Local Authentication
<a class="slurm_link" href="#local_auth"></a>
</h2>
<p>slurmrestd supports using UNIX domain sockets to have the kernel
authenticate local users. slurmrestd must be run as SlurmUser or root to allow
multiple different users at the same time but it is not required if users wish to run
as only themselves.
Slurmrestd must be located in the Munge security domain in order to function
and communicate with Slurm in local authentication mode.
</p>

<!--
<h2>Authenticating Proxy</h2>
<p>If (relatively) untrusted users are going to be allowed to talk to the REST
API, then they must be authenticated. There are a whole world of
authentications that a site could choose from at any one time. This
functionality is explicitly not provided in Slurmrestd itself but instead is
expected to be provided by an authenticating proxy and relay.</p>

<h2>Authenticating Relay</h2>
<p>An authenticating relay will act as the intermediary between Slurmrestd and
any clients. The proxy will accept REST API requests, process them and then
replicate them to the Slurm REST daemon directly as a trusted request.
The relay will have the ability to modify or apply site rules to user requests as
it processes each one before passing it along. This allows the most flexibility
for sites but will require coding a system to relay and adds latency. Some example
third party frameworks already exist and can be modified for this purpose:</p>
<ul>
	<li><a href="https://github.com/relayphp/Relay.Relay">PHP Relay</a></li>
	<li><a href="https://www.npmjs.com/package/node-relay">NodeJS Relay</a></li>
	<li><a href="https://github.com/shingetsu-gou/http-relay">Go http-relay</a></li>
</ul>

<h4>Authentication</h4>
<p>An authenticating proxy will act as the authentication authority but proxy all
user requests to Slurmrestd without inspection or modification. This allows a site
to implement authentication but avoids the latency hit of processing every request. It
is also the (lightly) preferred route as a relatively popular architecture and is
already supported by <a href="https://www.nginx.com/">NGiNX</a>.

<h5>Example Simple Authenticating Proxy</h5>
<p>An example is provided of how to potentially setup a <b>very</b> simple
authenticating proxy. This example provides a single test user that is harded
coded to the Unix ID 1000. This example is provided to show the general setup of
getting NGINX as an authenticating proxy but not to implment site specific
authentication. The example uses PHP sessions to created a trusted cookie on the
client connection but does not expose the API key or user id to the user or allow
them to directly modify it. NGINX enforces the requirement that the client be
authenticated and will not pass along any requests until authenticated.</p>

<h6>Setup:</h6>
<p>The example assumes that Slurmrestd is running on the localhost on port 9999.
The example also assumes that user 1000 exists and that the Slurm API key is "test".
The example is a dockerfile along with the required files to run. The docker image
is based on Alpine Linux and should run on any x86 machine unmodified. The running
user must be able to run docker commands.</p>
<p>The sample has the following files:</p>
<ul>
	<li>auth.php: PHP code to request user name and password. It will then start a
	PHP session and set the user id.</li>
	<li>Dockerfile: Alpine linux image based build procedure. It will install NGiNX
	and PHP and configure them to run as the default docker command.</li>
	<li>Makefile: Builds the docker image and runs the instance.</li>
	<li>nginx.conf: Uses the ngx_http_auth_request_module module to enforce authentication
	of /slurm/* and /openapi/*.</li>
	<li>validate.php: Validates that the PHP session exists and has a user id. It then
	sets the SLURM user id header.</li>
	<li>www.conf: Basic untuned PHP FPM configuration.</li>
</ul>

<h6>Security:</h6>
<p>The docker instance will run on the host network. Please make sure to avoid running
it on a non-trusted or shared environment as the user and password are well documented.
The example is <b>not</b> provided to be run in production.</p>

<h6>Procedure:</h6>
<ol>
	<li>
		Goto the example directory:
		<pre>cd contribs/auth_proxy_example/simple</pre>
	</li>
	<li>
		Start docker daemon:
		<pre>make</pre>
	</li>
	<li>
		Navigate to the ping diagnostic test to verify unknown users are rejected:
		<a href="http://127.0.0.1:8080/slurm/v1/ping/">Ping Test</a>.
	</li>
	<li>
		From a browser on the machine or a tunnel, navigate to this url:
		<a href="http://127.0.0.1:8080/auth/">Auth</a>.
		Enter in the user "test" and password "test".
	</li>
	<li>
		Now nagivate the browser to the ping diagnostic test to verify the
		login works: <a href="http://127.0.0.1:8080/slurm/v1/ping/">Ping Test</a>.
	</li>
</ol>

<h6>See also:</h6>
<ul>
	<li>
		<a href="https://developer.okta.com/blog/2018/08/28/nginx-auth-request">
			Okta NGiNX Blog post
		</a>
	</li>
</ul>

<h4>Example oauth2 authentication proxy</h4>
<p>TODO</p>

<h6>See also:</h6>
<ul>
	<li>
		<a href="https://github.com/bitly/oauth2_proxy">
			Oauth2 Proxy
		</a>
	</li>
	<li>
		<a href="https://www.ory.sh/run-oauth2-server-open-source-api-security">
			Ory OAuth2 Server
		</a>
	</li>
	<li>
		<a href="https://github.com/authlib/example-oauth2-server">
			Authlib Example Oauth2 Server
		</a>
	</li>
	<li>
		<a href="https://docs.authlib.org/en/latest/flask/2/authorization-server.html">
			Flask Authlib Oauth2 Server
		</a>
	</li>
	<li>
		<a href="https://hackernoon.com/build-your-own-oauth2-server-in-go-7d0f660732c3?gi=330e651f8b4b">
			GO based Oauth2 Server
		</a>
	</li>
</ul>
-->

<hr size=4 width="100%">

<p style="text-align:center;">Last modified 17 September 2021</p>

<!--#include virtual="footer.txt"-->
